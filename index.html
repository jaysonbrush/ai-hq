<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI HQ</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #1a1a2e;
    }
    body {
      display: flex;
      flex-direction: column;
      font-family: 'Courier New', monospace;
      color: #eee;
    }
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 8px;
    }
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 16px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      margin-bottom: 8px;
    }
    h1 {
      font-size: 18px;
      color: #fff;
      letter-spacing: 3px;
      text-shadow: 2px 2px 0 #4a6fa5;
    }
    .editable-title {
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .editable-title:hover {
      background: rgba(255,255,255,0.1);
    }
    .title-input {
      font-size: 18px;
      font-family: inherit;
      letter-spacing: 3px;
      background: rgba(0,0,0,0.3);
      border: 2px solid #4a6fa5;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      outline: none;
      width: 200px;
    }
    .status-bar {
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 12px;
    }
    .session-count {
      color: #4aff4a;
    }
    .canvas-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius: 6px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .controls {
      display: flex;
      gap: 8px;
      padding: 8px;
      justify-content: center;
    }
    button {
      background: #3a3a5e;
      border: 2px solid #4a6fa5;
      color: #aaa;
      padding: 6px 16px;
      font-family: inherit;
      font-size: 11px;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover { background: #4a4a6e; color: #fff; }
    button.primary { background: #4a6fa5; color: #fff; }

    .session-panel {
      position: fixed;
      top: 60px;
      right: 16px;
      background: rgba(20, 20, 35, 0.95);
      border: 2px solid #4a6fa5;
      border-radius: 8px;
      padding: 12px;
      min-width: 220px;
      max-width: 300px;
      max-height: 400px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .session-panel h3 {
      font-size: 12px;
      color: #4a9eff;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid #333;
      letter-spacing: 1px;
    }
    .session-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .session-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: rgba(60, 60, 90, 0.4);
      border-radius: 4px;
      font-size: 11px;
    }
    .session-number {
      width: 22px;
      height: 22px;
      border-radius: 4px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 12px;
      color: #fff;
      text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
    }
    .session-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .session-dot.typing { background: #4aff4a; box-shadow: 0 0 8px #4aff4a; }
    .session-dot.thinking { background: #ffaa40; box-shadow: 0 0 8px #ffaa40; }
    .session-dot.idle { background: #888; }
    .session-dot.walking { background: #40aaff; box-shadow: 0 0 8px #40aaff; }
    .session-info {
      flex: 1;
      min-width: 0;
    }
    .session-title {
      color: #fff;
      font-weight: bold;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .session-state {
      color: #888;
      font-size: 10px;
      text-transform: capitalize;
    }
    .session-empty {
      color: #666;
      font-size: 11px;
      font-style: italic;
      padding: 10px 0;
    }

    .setup-toggle {
      display: none;
    }

    .setup-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a2e;
      border: 2px solid #4a6fa5;
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 800px;
      max-height: 85vh;
      overflow-y: auto;
      z-index: 200;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    .setup-panel.visible { display: block; }
    .setup-panel h2 {
      color: #4a9eff;
      margin-bottom: 16px;
      font-size: 20px;
    }
    .setup-panel h3 {
      color: #6ab0ff;
      margin: 20px 0 10px 0;
      font-size: 14px;
    }
    .setup-panel p {
      color: #ccc;
      font-size: 13px;
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .setup-panel code {
      background: #2a2a4e;
      padding: 2px 6px;
      border-radius: 3px;
      color: #4aff4a;
      font-size: 12px;
    }
    .setup-panel pre {
      background: #0d0d1a;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 12px;
      overflow-x: auto;
      font-size: 11px;
      color: #aaa;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .setup-close {
      position: absolute;
      top: 12px;
      right: 12px;
      background: none;
      border: none;
      color: #888;
      font-size: 24px;
      cursor: pointer;
      padding: 0 8px;
    }
    .setup-close:hover { color: #fff; }
    .setup-note {
      background: #2a3a4e;
      border-left: 3px solid #4a9eff;
      padding: 12px;
      margin-top: 20px;
      font-size: 12px;
      color: #aaa;
    }
    .setup-note strong { color: #fff; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 id="headerTitle" class="editable-title" onclick="editTitle()">AI HQ</h1>
      <div class="status-bar">
        <span class="session-count" id="sessionCount">0 active sessions</span>
      </div>
    </div>
    <div class="canvas-wrapper">
      <canvas id="office"></canvas>
    </div>

    <div class="session-panel">
      <h3>ACTIVE SESSIONS</h3>
      <div class="session-list" id="sessionList">
        <div class="session-empty">No active sessions</div>
      </div>
    </div>

    <button class="setup-toggle" onclick="toggleSetup()">Setup Guide</button>
    <div class="setup-panel" id="setupPanel">
      <button class="setup-close" onclick="toggleSetup()">&times;</button>
      <h2>AI HQ Setup</h2>
      <p>This is a pixel art office that visualizes Claude Code sessions in real-time. Follow these steps to connect your Claude Code session:</p>

      <h3>Step 1: Create the event script</h3>
      <p>Save this as <code id="scriptPath">C:/Users/YOUR_USER/ai-hq/send-event.ps1</code>:</p>
      <pre id="scriptContent"></pre>

      <h3>Step 2: Add hooks to Claude Code settings</h3>
      <p>Add this to your <code>~/.claude/settings.json</code> (merge with existing settings if needed):</p>
      <pre id="hooksConfig"></pre>

      <h3>Step 3: Restart Claude Code</h3>
      <p>Restart your Claude Code session for the hooks to take effect. Your character will appear in the office!</p>

      <div class="setup-note">
        <strong>Note:</strong> The server URL shown above is based on how you accessed this page.
        Make sure other machines can reach <span id="serverAddress"></span>
      </div>
    </div>
    <div class="controls">
      <button class="primary" onclick="pixelOffice.addSession()">New Session</button>
      <button onclick="pixelOffice.removeSession()">End Session</button>
      <button onclick="pixelOffice.setSessionState('typing')">Coding</button>
      <button onclick="pixelOffice.setSessionState('thinking')">Thinking</button>
      <button onclick="pixelOffice.setSessionState('idle')">Idle</button>
    </div>
  </div>

<script>
// Configurable office title
let officeTitle = localStorage.getItem('officeTitle') || 'AI HQ';

// Sync title on page load
document.getElementById('headerTitle').textContent = officeTitle;
document.title = officeTitle;

function editTitle() {
  const h1 = document.getElementById('headerTitle');
  const currentTitle = h1.textContent;
  h1.innerHTML = `<input type="text" class="title-input" value="${currentTitle}" onblur="saveTitle(this)" onkeydown="if(event.key==='Enter')this.blur()">`;
  h1.querySelector('input').focus();
  h1.querySelector('input').select();
}

function saveTitle(input) {
  officeTitle = input.value || 'AI HQ';
  localStorage.setItem('officeTitle', officeTitle);
  document.getElementById('headerTitle').textContent = officeTitle;
  document.title = officeTitle;
}

const pixelOffice = (() => {
  const canvas = document.getElementById('office');
  const ctx = canvas.getContext('2d');

  // Canvas sizing
  let W, H, SCALE;
  function resize() {
    const container = document.querySelector('.canvas-wrapper');
    const maxW = container.clientWidth - 20;
    const maxH = container.clientHeight - 20;
    const aspect = 16 / 9;

    if (maxW / maxH > aspect) {
      H = maxH;
      W = H * aspect;
    } else {
      W = maxW;
      H = W / aspect;
    }

    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    canvas.width = 1280;
    canvas.height = 720;
    W = 1280;
    H = 720;
  }
  resize();
  window.addEventListener('resize', resize);

  // Hidden restart button - click the sun to restart server!
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    // Sun is at (100, 80) with radius 40
    const sunX = 100, sunY = 80, sunR = 45;
    const dist = Math.sqrt((x - sunX) ** 2 + (y - sunY) ** 2);
    if (dist < sunR) {
      console.log('[PixelOffice] Restarting server...');
      fetch('/restart').then(() => {
        setTimeout(() => location.reload(), 1500);
      });
    }
  });

  // Colors - refined palette
  const C = {
    sky: '#87CEEB',
    skyBottom: '#B0E0E6',
    grass: '#228B22',
    grassDark: '#006400',
    grassLight: '#32CD32',
    dirt: '#8B7355',
    road: '#3a3a3a',
    roadLine: '#f0e068',
    sidewalk: '#d0c8b8',

    brickLight: '#CD853F',
    brickDark: '#A0522D',
    brickMortar: '#D2B48C',
    roofDark: '#2F4F4F',
    roofLight: '#708090',

    wallInterior: '#FFF8DC',
    wallTrim: '#DEB887',
    floorWood: '#DEB887',
    floorWoodDark: '#D2A679',
    floorWoodLight: '#E8C99B',
    tileCyan: '#E0FFFF',
    tileCyanDark: '#AFEEEE',

    deskTop: '#F5DEB3',
    deskFront: '#D2A679',
    deskLeg: '#8B7355',
    chairBlue: '#4169E1',
    chairBlueDark: '#1E3A8A',
    chairBlueLight: '#6495ED',

    monitor: '#1a1a2e',
    monitorFrame: '#2d2d44',
    screenOff: '#0a0a15',
    screenOn: '#001a00',
    screenGlow: '#00ff41',

    plantGreen: '#228B22',
    plantDark: '#006400',
    plantLight: '#32CD32',
    pot: '#CD853F',
    potDark: '#A0522D',

    bushDark: '#006400',
    bushMid: '#228B22',
    bushLight: '#32CD32',
    treeTrunk: '#8B4513',
    treeTrunkDark: '#654321',

    windowFrame: '#4a4a5a',
    windowGlass: '#87CEEB',
    windowReflect: '#B0E0E6',
    doorFrame: '#654321',
    door: '#8B4513',
    doorHandle: '#FFD700',

    skin: '#f0c8a0',
    skinShade: '#d8b088',

    shadow: 'rgba(0,0,0,0.15)',
  };

  // Hair and shirt colors for variety
  const HAIR_COLORS = ['#302820', '#604830', '#806040', '#a08050', '#f0c040', '#c04020', '#202020'];
  const SHIRT_COLORS = ['#4080d0', '#d04080', '#40b070', '#d0a040', '#8040d0', '#40a0a0', '#d06040'];

  // Special character types (rare!)
  const SPECIAL_TYPES = [
    { type: 'alien', chance: 0.03, skin: '#90EE90', hair: '#00ff00', eyes: '#000', eyeShape: 'big' },
    { type: 'robot', chance: 0.03, skin: '#a0a0b0', hair: '#606070', eyes: '#ff0000', eyeShape: 'led' },
    { type: 'werewolf', chance: 0.02, skin: '#8B7355', hair: '#4a3728', eyes: '#ffcc00', eyeShape: 'wolf' },
    { type: 'vampire', chance: 0.02, skin: '#e8e8e8', hair: '#1a1a1a', eyes: '#cc0000', eyeShape: 'normal' },
    { type: 'ninja', chance: 0.02, skin: '#2a2a2a', hair: '#1a1a1a', eyes: '#fff', eyeShape: 'narrow' },
    { type: 'zombie', chance: 0.02, skin: '#7a9972', hair: '#3a4a3a', eyes: '#ffffff', eyeShape: 'dead' },
  ];

  function rollSpecialCharacter() {
    const roll = Math.random();
    let cumulative = 0;
    for (const special of SPECIAL_TYPES) {
      cumulative += special.chance;
      if (roll < cumulative) return special;
    }
    return null; // Normal human
  }

  // Layout constants - TWO STORY BUILDING (compact)
  const GROUND_Y = 620;
  const BUILDING_LEFT = 200;
  const BUILDING_RIGHT = 1150;
  const BUILDING_TOP = 180;  // Raised up - shorter building

  // Floor levels - compressed
  const FLOOR_2_Y = 320;  // Second floor level (top)
  const FLOOR_1_Y = 540;  // First floor level (bottom)
  const FLOOR_DIVIDER = 400; // Y position of floor divider - moved down

  const STAIRS_X = 820; // X position of stairwell
  const DIVIDER_X = 750; // Separates office from break room on floor 1

  // Desk positions - spread across building
  // facing: 'down' means character sits ABOVE/BEHIND desk (monitor in foreground)
  const DESKS = [
    // 2nd floor - Office area (left of stairs) - all in a line
    { x: 240, y: 340, facing: 'down', occupied: false, floor: 2, type: 'workstation' },
    { x: 340, y: 340, facing: 'down', occupied: false, floor: 2, type: 'workstation' },
    { x: 440, y: 340, facing: 'down', occupied: false, floor: 2, type: 'workstation' },
    { x: 540, y: 340, facing: 'down', occupied: false, floor: 2, type: 'workstation' },
    { x: 640, y: 340, facing: 'down', occupied: false, floor: 2, type: 'workstation' },
    // 2nd floor - Executive office (right of stairs) - NPC desk
    { x: 960, y: 340, facing: 'down', occupied: true, floor: 2, type: 'executive', npc: true },
    // 1st floor - Secretary desk in lobby - NPC desk (centered between windows, lower)
    { x: 440, y: GROUND_Y - 70, facing: 'down', occupied: true, floor: 1, type: 'secretary', npc: true },
  ];

  // Whiteboard position for thinking characters (centered between windows)
  const WHITEBOARD_POS = { x: 420, y: FLOOR_DIVIDER - 50, floor: 2 };

  // Character Y positions on each floor (standing height)
  const CHAR_FLOOR_2_Y = FLOOR_DIVIDER - 40; // Characters on 2nd floor stand here
  const CHAR_FLOOR_1_Y = GROUND_Y - 50;      // Characters on 1st floor stand here

  // Wander points (general)
  const WANDER_POINTS = [
    // 2nd floor - office area (left of stairs)
    { x: 350, y: CHAR_FLOOR_2_Y, floor: 2 },
    { x: 500, y: CHAR_FLOOR_2_Y, floor: 2 },
    { x: 700, y: CHAR_FLOOR_2_Y, floor: 2 },
    // 2nd floor - executive office (right of stairs)
    { x: 950, y: CHAR_FLOOR_2_Y, floor: 2 },
    { x: 1050, y: CHAR_FLOOR_2_Y, floor: 2 },
    // 1st floor - lobby
    { x: 350, y: CHAR_FLOOR_1_Y, floor: 1 },
    { x: 500, y: CHAR_FLOOR_1_Y, floor: 1 },
    { x: 650, y: CHAR_FLOOR_1_Y, floor: 1 },
  ];

  // Break room activity points (where characters go when idle)
  // Characters need higher Y (closer to viewer) to appear IN FRONT of furniture
  const BREAK_ROOM_Y = GROUND_Y - 40;  // Character Y position in break room (in front of furniture)
  const BREAK_ROOM_POINTS = [
    { x: 940, y: BREAK_ROOM_Y, floor: 1, activity: 'couch' },       // In front of couch
    { x: 990, y: BREAK_ROOM_Y, floor: 1, activity: 'couch' },       // Other end of couch
    { x: BUILDING_RIGHT - 55, y: BREAK_ROOM_Y, floor: 1, activity: 'vending' },  // Vending machine
    { x: STAIRS_X + 210, y: BREAK_ROOM_Y, floor: 1, activity: 'coffee' },  // Coffee machine
  ];

  // Stair waypoints for pathfinding (positioned at stair landings)
  const STAIRS_BOTTOM = { x: STAIRS_X + 45, y: GROUND_Y - 50 };  // Bottom of stairs
  const STAIRS_TOP = { x: STAIRS_X + 45, y: FLOOR_DIVIDER - 40 };  // Top of stairs

  let frame = 0;
  let sessions = []; // Each session = { id, character }

  // Waypoints for pathfinding between floors
  const ENTRANCE_POINT = { x: BUILDING_LEFT + 30, y: CHAR_FLOOR_1_Y };  // Side entrance
  const LOBBY_POINT = { x: 400, y: CHAR_FLOOR_1_Y };

  // Character class
  class Character {
    constructor(id, deskIndex, title = null) {
      this.id = id;
      this.deskIndex = deskIndex;
      this.title = title || `Session ${id + 1}`;
      this.x = 50; // Start outside
      this.y = GROUND_Y - 40;
      this.floor = 0; // 0 = outside, 1 = first floor, 2 = second floor
      this.targetX = this.x;
      this.targetY = this.y;
      this.state = 'entering'; // entering, working, wandering, leaving
      this.actualState = 'idle'; // What the session is doing: typing, thinking, idle
      // Check for rare special character!
      this.special = rollSpecialCharacter();
      if (this.special) {
        this.skin = this.special.skin;
        this.hair = this.special.hair;
        this.eyes = this.special.eyes;
        this.eyeShape = this.special.eyeShape;
        this.shirt = SHIRT_COLORS[id % SHIRT_COLORS.length]; // Keep shirt for number visibility
      } else {
        this.skin = C.skin;
        this.hair = HAIR_COLORS[id % HAIR_COLORS.length];
        this.eyes = '#000';
        this.eyeShape = 'normal';
        this.shirt = SHIRT_COLORS[id % SHIRT_COLORS.length];
      }
      this.frame = Math.random() * 100;
      this.wanderTimer = 0;
      this.facingRight = true;
      this.pathQueue = []; // Queue of waypoints to visit
      this.speechBubble = null;
      this.speechTimer = 0;
      this.chatCooldown = 0; // Prevent constant chatting
    }

    getDisplayState() {
      if (this.state === 'entering') return 'arriving';
      if (this.state === 'leaving') return 'leaving';
      if (this.isWalking()) return 'walking';
      return this.actualState;
    }

    getDesk() {
      return DESKS[this.deskIndex];
    }

    setTarget(x, y) {
      this.targetX = x;
      this.targetY = y;
    }

    // Build path from current location to desk
    buildPathToDesk() {
      const desk = this.getDesk();
      const deskCharX = desk.x + (desk.type === 'executive' ? 55 : desk.type === 'secretary' ? 50 : 30);
      const deskCharY = desk.facing === 'up' ? desk.y + 60 : desk.y - 10;
      const targetFloor = desk.floor;

      this.pathQueue = [];

      if (this.floor === 0) {
        // Outside -> entrance -> 1st floor
        this.pathQueue.push({ x: ENTRANCE_POINT.x, y: GROUND_Y - 40, floor: 0 });
        this.pathQueue.push({ x: ENTRANCE_POINT.x, y: CHAR_FLOOR_1_Y, floor: 1 });

        if (targetFloor === 2) {
          // Need to go upstairs
          this.pathQueue.push({ x: STAIRS_BOTTOM.x, y: STAIRS_BOTTOM.y, floor: 1 });
          this.pathQueue.push({ x: STAIRS_TOP.x, y: STAIRS_TOP.y, floor: 2 });
        }
        this.pathQueue.push({ x: deskCharX, y: deskCharY, floor: targetFloor });
      } else if (this.floor === 1 && targetFloor === 2) {
        // 1st floor -> stairs -> 2nd floor desk
        this.pathQueue.push({ x: STAIRS_BOTTOM.x, y: STAIRS_BOTTOM.y, floor: 1 });
        this.pathQueue.push({ x: STAIRS_TOP.x, y: STAIRS_TOP.y, floor: 2 });
        this.pathQueue.push({ x: deskCharX, y: deskCharY, floor: 2 });
      } else if (this.floor === 2 && targetFloor === 1) {
        // 2nd floor -> stairs -> 1st floor desk
        this.pathQueue.push({ x: STAIRS_TOP.x, y: STAIRS_TOP.y, floor: 2 });
        this.pathQueue.push({ x: STAIRS_BOTTOM.x, y: STAIRS_BOTTOM.y, floor: 1 });
        this.pathQueue.push({ x: deskCharX, y: deskCharY, floor: 1 });
      } else {
        // Already on correct floor, go directly
        this.pathQueue.push({ x: deskCharX, y: deskCharY, floor: targetFloor });
      }
    }

    // Build path from current location to exit
    buildPathToExit() {
      this.pathQueue = [];

      if (this.floor === 2) {
        // 2nd floor -> stairs -> lobby -> entrance -> outside
        this.pathQueue.push({ x: STAIRS_TOP.x, y: STAIRS_TOP.y, floor: 2 });
        this.pathQueue.push({ x: STAIRS_BOTTOM.x, y: STAIRS_BOTTOM.y, floor: 1 });
        this.pathQueue.push({ x: ENTRANCE_POINT.x, y: CHAR_FLOOR_1_Y, floor: 1 });
        this.pathQueue.push({ x: ENTRANCE_POINT.x, y: GROUND_Y - 40, floor: 0 });
        this.pathQueue.push({ x: 50, y: GROUND_Y - 40, floor: 0 });
      } else if (this.floor === 1) {
        // 1st floor -> entrance -> outside
        this.pathQueue.push({ x: ENTRANCE_POINT.x, y: CHAR_FLOOR_1_Y, floor: 1 });
        this.pathQueue.push({ x: ENTRANCE_POINT.x, y: GROUND_Y - 40, floor: 0 });
        this.pathQueue.push({ x: 50, y: GROUND_Y - 40, floor: 0 });
      } else {
        // Already outside
        this.pathQueue.push({ x: 50, y: GROUND_Y - 40, floor: 0 });
      }
    }

    update() {
      this.frame++;

      // Speech bubble timer
      if (this.speechTimer > 0) {
        this.speechTimer--;
        if (this.speechTimer <= 0) {
          this.speechBubble = null;
        }
      }
      if (this.chatCooldown > 0) this.chatCooldown--;

      // Check for nearby idle characters to chat with
      if (this.actualState === 'idle' && !this.isWalking() && this.chatCooldown <= 0 && !this.speechBubble) {
        const nearbyChars = sessions
          .map(s => s.character)
          .filter(c => c !== this &&
                       c.actualState === 'idle' &&
                       !c.isWalking() &&
                       c.floor === this.floor &&
                       Math.abs(c.x - this.x) < 100 &&
                       Math.abs(c.y - this.y) < 50);

        if (nearbyChars.length > 0 && Math.random() < 0.02) {
          // Start a conversation!
          this.speechBubble = CHAT_PHRASES[Math.floor(Math.random() * CHAT_PHRASES.length)];
          this.speechTimer = 90;
          this.chatCooldown = 200;

          // Other character responds after a delay
          const other = nearbyChars[0];
          if (!other.speechBubble) {
            setTimeout(() => {
              if (other.actualState === 'idle' && !other.isWalking()) {
                other.speechBubble = CHAT_PHRASES[Math.floor(Math.random() * CHAT_PHRASES.length)];
                other.speechTimer = 90;
                other.chatCooldown = 200;
              }
            }, 1000 + Math.random() * 500);
          }
        }
      }

      const desk = this.getDesk();
      const deskCharX = desk.x + 40;
      const deskCharY = desk.facing === 'up' ? desk.y + 60 : desk.y - 35;

      // State machine
      if (this.state === 'entering') {
        // Build path if needed
        if (this.pathQueue.length === 0) {
          this.buildPathToDesk();
        }

        // Follow path
        if (this.pathQueue.length > 0) {
          const next = this.pathQueue[0];
          this.setTarget(next.x, next.y);
          if (this.distToTarget() < 5) {
            this.floor = next.floor;
            this.pathQueue.shift();
            if (this.pathQueue.length === 0) {
              this.state = 'working';
              this.floor = desk.floor;
              this.x = deskCharX;
              this.y = deskCharY;
            }
          }
        }
      } else if (this.state === 'leaving') {
        // Build path if needed
        if (this.pathQueue.length === 0) {
          this.buildPathToExit();
        }

        // Follow path
        if (this.pathQueue.length > 0) {
          const next = this.pathQueue[0];
          this.setTarget(next.x, next.y);
          if (this.distToTarget() < 5) {
            this.floor = next.floor;
            this.pathQueue.shift();
          }
        }
      } else if (this.actualState === 'idle') {
        // Go to break room when idle

        // First, follow any existing path
        if (this.pathQueue && this.pathQueue.length > 0) {
          const next = this.pathQueue[0];
          this.setTarget(next.x, next.y);
          if (this.distToTarget() < 5) {
            this.floor = next.floor;
            this.pathQueue.shift();
          }
          this.state = 'wandering';
        } else {
          // No path - either pick new destination or stay put
          this.wanderTimer--;
          if (this.wanderTimer <= 0) {
            // Pick a break room activity
            const breakPoint = BREAK_ROOM_POINTS[Math.floor(Math.random() * BREAK_ROOM_POINTS.length)];

            // Build path to break room
            this.pathQueue = [];
            if (this.floor === 2) {
              this.pathQueue.push({ x: STAIRS_TOP.x, y: STAIRS_TOP.y, floor: 2 });
              this.pathQueue.push({ x: STAIRS_BOTTOM.x, y: STAIRS_BOTTOM.y, floor: 1 });
            } else if (this.floor === 0) {
              this.pathQueue.push({ x: ENTRANCE_POINT.x, y: CHAR_FLOOR_1_Y, floor: 1 });
            }
            this.pathQueue.push({ x: breakPoint.x, y: breakPoint.y, floor: 1 });
            this.idleActivity = breakPoint.activity;

            this.wanderTimer = 400 + Math.random() * 500; // Longer break times
            this.state = 'wandering';
          }
        }
      } else if (this.actualState === 'typing') {
        // Go to desk (need to path if on different floor)
        const targetFloor = desk.floor;
        if (this.floor !== targetFloor) {
          if (this.pathQueue.length === 0) {
            this.buildPathToDesk();
          }
          if (this.pathQueue.length > 0) {
            const next = this.pathQueue[0];
            this.setTarget(next.x, next.y);
            if (this.distToTarget() < 5) {
              this.floor = next.floor;
              this.pathQueue.shift();
              if (this.pathQueue.length === 0) {
                this.state = 'working';
                this.floor = targetFloor;
              }
            }
          }
        } else {
          this.setTarget(deskCharX, deskCharY);
          if (this.distToTarget() < 5) {
            this.state = 'working';
            this.floor = targetFloor;
          }
        }
      } else if (this.actualState === 'thinking') {
        // Randomly decide: go to whiteboard or desk (30% chance whiteboard)
        if (this.thinkingTarget === undefined) {
          this.thinkingTarget = Math.random() < 0.3 ? 'whiteboard' : 'desk';
        }

        if (this.thinkingTarget === 'whiteboard') {
          // Go to whiteboard
          const targetFloor = WHITEBOARD_POS.floor;
          if (this.floor !== targetFloor) {
            if (this.pathQueue.length === 0) {
              this.pathQueue = [];
              if (this.floor === 1) {
                this.pathQueue.push({ x: STAIRS_BOTTOM.x, y: STAIRS_BOTTOM.y, floor: 1 });
                this.pathQueue.push({ x: STAIRS_TOP.x, y: STAIRS_TOP.y, floor: 2 });
              } else if (this.floor === 0) {
                this.pathQueue.push({ x: ENTRANCE_POINT.x, y: CHAR_FLOOR_1_Y, floor: 1 });
                this.pathQueue.push({ x: STAIRS_BOTTOM.x, y: STAIRS_BOTTOM.y, floor: 1 });
                this.pathQueue.push({ x: STAIRS_TOP.x, y: STAIRS_TOP.y, floor: 2 });
              }
              this.pathQueue.push({ x: WHITEBOARD_POS.x, y: WHITEBOARD_POS.y, floor: 2 });
            }
            if (this.pathQueue.length > 0) {
              const next = this.pathQueue[0];
              this.setTarget(next.x, next.y);
              if (this.distToTarget() < 5) {
                this.floor = next.floor;
                this.pathQueue.shift();
                if (this.pathQueue.length === 0) {
                  this.state = 'working';
                  this.floor = targetFloor;
                }
              }
            }
          } else {
            this.setTarget(WHITEBOARD_POS.x, WHITEBOARD_POS.y);
            if (this.distToTarget() < 5) {
              this.state = 'working';
              this.floor = targetFloor;
            }
          }
        } else {
          // Go to desk (same as typing)
          const targetFloor = desk.floor;
          if (this.floor !== targetFloor) {
            if (this.pathQueue.length === 0) {
              this.buildPathToDesk();
            }
            if (this.pathQueue.length > 0) {
              const next = this.pathQueue[0];
              this.setTarget(next.x, next.y);
              if (this.distToTarget() < 5) {
                this.floor = next.floor;
                this.pathQueue.shift();
                if (this.pathQueue.length === 0) {
                  this.state = 'working';
                  this.floor = targetFloor;
                }
              }
            }
          } else {
            this.setTarget(deskCharX, deskCharY);
            if (this.distToTarget() < 5) {
              this.state = 'working';
              this.floor = targetFloor;
            }
          }
        }
      }

      // Movement
      const dx = this.targetX - this.x;
      const dy = this.targetY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > 3) {
        const speed = 2.5;
        this.x += (dx / dist) * speed;
        this.y += (dy / dist) * speed;
        this.facingRight = dx > 0;
      }
    }

    distToTarget() {
      const dx = this.targetX - this.x;
      const dy = this.targetY - this.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    isWalking() {
      return this.distToTarget() > 5;
    }

    draw() {
      const x = Math.floor(this.x);
      const y = Math.floor(this.y);
      const walking = this.isWalking();
      const bounce = walking ? Math.sin(this.frame * 0.3) * 2 : 0;
      const typingBounce = (this.state === 'working' && this.actualState === 'typing') ? Math.sin(this.frame * 0.2) : 0;

      // Shadow
      ctx.fillStyle = C.shadow;
      ctx.beginPath();
      ctx.ellipse(x, y + 36, 12, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Legs
      if (walking) {
        const legAnim = Math.sin(this.frame * 0.3) * 4;
        rect(x - 6, y + 22 + bounce, 5, 12, '#404060');
        rect(x + 1, y + 22 + bounce, 5, 12, '#404060');
      } else {
        rect(x - 6, y + 22, 5, 12, '#404060');
        rect(x + 1, y + 22, 5, 12, '#404060');
      }

      // Body
      rect(x - 8, y + 4 + bounce + typingBounce, 16, 20, this.shirt);

      // Arms
      const skinColor = this.skin || C.skin;
      if (this.state === 'working' && this.actualState === 'typing') {
        const armAnim = Math.floor(this.frame / 6) % 2;
        rect(x - 12, y + 8 + typingBounce + armAnim, 6, 12, skinColor);
        rect(x + 6, y + 8 + typingBounce + (1 - armAnim), 6, 12, skinColor);
      } else if (this.state === 'working' && this.actualState === 'thinking') {
        // Hand on chin
        rect(x - 12, y + 10, 6, 10, skinColor);
        rect(x + 6, y + 2, 6, 14, skinColor);
      } else {
        rect(x - 12, y + 8 + bounce, 6, 12, skinColor);
        rect(x + 6, y + 8 + bounce, 6, 12, skinColor);
      }

      // Head
      rect(x - 8, y - 14 + bounce + typingBounce, 16, 18, skinColor);

      // Special character features
      if (this.special) {
        if (this.special.type === 'alien') {
          // Alien antenna
          rect(x - 2, y - 26 + bounce + typingBounce, 2, 8, '#00cc00');
          rect(x + 1, y - 26 + bounce + typingBounce, 2, 8, '#00cc00');
          ctx.fillStyle = '#00ff00';
          ctx.beginPath();
          ctx.arc(x - 1, y - 28 + bounce + typingBounce, 3, 0, Math.PI * 2);
          ctx.arc(x + 2, y - 28 + bounce + typingBounce, 3, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.special.type === 'werewolf') {
          // Werewolf ears
          rect(x - 10, y - 22 + bounce + typingBounce, 5, 8, this.hair);
          rect(x + 5, y - 22 + bounce + typingBounce, 5, 8, this.hair);
          // Furry face
          rect(x - 10, y - 10 + bounce + typingBounce, 3, 6, this.hair);
          rect(x + 7, y - 10 + bounce + typingBounce, 3, 6, this.hair);
        } else if (this.special.type === 'robot') {
          // Robot antenna
          rect(x - 1, y - 22 + bounce + typingBounce, 3, 6, '#606070');
          rect(x - 2, y - 26 + bounce + typingBounce, 5, 4, '#ff0000');
        } else if (this.special.type === 'vampire') {
          // Vampire cape collar
          rect(x - 12, y + 2 + bounce + typingBounce, 4, 12, '#2a0a0a');
          rect(x + 8, y + 2 + bounce + typingBounce, 4, 12, '#2a0a0a');
        } else if (this.special.type === 'ninja') {
          // Ninja headband
          rect(x - 10, y - 12 + bounce + typingBounce, 20, 3, '#cc0000');
        } else if (this.special.type === 'zombie') {
          // Zombie torn clothes effect
          rect(x - 9, y + 20 + bounce + typingBounce, 3, 4, skinColor);
          rect(x + 6, y + 18 + bounce + typingBounce, 3, 6, skinColor);
        }
        // Hair (different for some types)
        if (this.special.type !== 'ninja' && this.special.type !== 'robot') {
          rect(x - 9, y - 18 + bounce + typingBounce, 18, 8, this.hair);
          rect(x - 10, y - 14 + bounce + typingBounce, 3, 8, this.hair);
          rect(x + 7, y - 14 + bounce + typingBounce, 3, 8, this.hair);
        } else if (this.special.type === 'robot') {
          // Robot head plate
          rect(x - 9, y - 18 + bounce + typingBounce, 18, 6, '#505060');
        }
      } else {
        // Normal hair
        rect(x - 9, y - 18 + bounce + typingBounce, 18, 8, this.hair);
        rect(x - 10, y - 14 + bounce + typingBounce, 3, 8, this.hair);
        rect(x + 7, y - 14 + bounce + typingBounce, 3, 8, this.hair);
      }

      // Eyes - different styles for special characters
      const eyeY = (this.actualState === 'thinking' && this.state === 'working') ? y - 10 : y - 8;
      const eyeColor = this.eyes || '#000';
      if (this.eyeShape === 'big') {
        // Big alien eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(x - 4, eyeY + 1 + bounce + typingBounce, 4, 5, 0, 0, Math.PI * 2);
        ctx.ellipse(x + 4, eyeY + 1 + bounce + typingBounce, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(x - 4, eyeY + bounce + typingBounce, 2, 0, Math.PI * 2);
        ctx.arc(x + 4, eyeY + bounce + typingBounce, 2, 0, Math.PI * 2);
        ctx.fill();
      } else if (this.eyeShape === 'led') {
        // Robot LED eyes
        const ledBlink = Math.floor(this.frame / 15) % 2;
        rect(x - 6, eyeY + bounce + typingBounce, 4, 3, ledBlink ? '#ff0000' : '#aa0000');
        rect(x + 2, eyeY + bounce + typingBounce, 4, 3, ledBlink ? '#ff0000' : '#aa0000');
      } else if (this.eyeShape === 'wolf') {
        // Wolf eyes (yellow, angular)
        rect(x - 5, eyeY + bounce + typingBounce, 4, 3, eyeColor);
        rect(x + 1, eyeY + bounce + typingBounce, 4, 3, eyeColor);
        rect(x - 4, eyeY + 1 + bounce + typingBounce, 2, 1, '#000');
        rect(x + 2, eyeY + 1 + bounce + typingBounce, 2, 1, '#000');
      } else if (this.eyeShape === 'narrow') {
        // Ninja narrow eyes
        rect(x - 5, eyeY + 1 + bounce + typingBounce, 4, 2, eyeColor);
        rect(x + 1, eyeY + 1 + bounce + typingBounce, 4, 2, eyeColor);
      } else if (this.eyeShape === 'dead') {
        // Zombie X eyes
        ctx.strokeStyle = eyeColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x - 6, eyeY - 1 + bounce + typingBounce);
        ctx.lineTo(x - 2, eyeY + 3 + bounce + typingBounce);
        ctx.moveTo(x - 2, eyeY - 1 + bounce + typingBounce);
        ctx.lineTo(x - 6, eyeY + 3 + bounce + typingBounce);
        ctx.moveTo(x + 2, eyeY - 1 + bounce + typingBounce);
        ctx.lineTo(x + 6, eyeY + 3 + bounce + typingBounce);
        ctx.moveTo(x + 6, eyeY - 1 + bounce + typingBounce);
        ctx.lineTo(x + 2, eyeY + 3 + bounce + typingBounce);
        ctx.stroke();
      } else {
        // Normal eyes
        rect(x - 5, eyeY + bounce + typingBounce, 3, 3, eyeColor);
        rect(x + 2, eyeY + bounce + typingBounce, 3, 3, eyeColor);
      }

      // Number on shirt
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(String(this.id + 1), x, y + 18 + bounce + typingBounce);
      ctx.textAlign = 'left';

      // Status indicators
      if (this.state === 'working') {
        if (this.actualState === 'typing') {
          // Code icon
          rect(x - 8, y - 32, 16, 10, '#40ff80');
          ctx.fillStyle = '#000';
          ctx.font = '8px monospace';
          ctx.fillText('</>', x - 7, y - 24);
        } else if (this.actualState === 'thinking') {
          // Thought bubble with gray border
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 2;
          ctx.fillStyle = '#fff';
          // Small dots
          ctx.beginPath();
          ctx.arc(x + 16, y - 20, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x + 24, y - 28, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          // Main bubble
          ctx.beginPath();
          ctx.arc(x + 36, y - 38, 14, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#333';
          ctx.font = 'bold 12px monospace';
          ctx.fillText('?', x + 32, y - 34);
        }
      }

      // Chat speech bubble (for idle conversations)
      if (this.speechBubble && this.speechTimer > 0) {
        const bubbleWidth = Math.max(50, this.speechBubble.length * 6 + 14);
        const bubbleX = x - bubbleWidth / 2;
        const bubbleY = y - 52;

        // Bubble background
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(bubbleX, bubbleY, bubbleWidth, 20, 5);
        ctx.fill();
        ctx.stroke();

        // Bubble tail
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(x - 4, bubbleY + 20);
        ctx.lineTo(x + 4, bubbleY + 20);
        ctx.lineTo(x, bubbleY + 27);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(x - 4, bubbleY + 19);
        ctx.lineTo(x, bubbleY + 27);
        ctx.lineTo(x + 4, bubbleY + 19);
        ctx.stroke();

        // Text
        ctx.fillStyle = '#333';
        ctx.font = '9px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.speechBubble, x, bubbleY + 14);
        ctx.textAlign = 'left';
      }
    }
  }

  // Casual conversation phrases for idle characters
  const CHAT_PHRASES = [
    "Nice weather!", "How's it going?", "Coffee?", "Almost done!",
    "Bug fixes...", "LGTM!", "Ship it!", "Need a review?",
    "Lunch soon?", "Great work!", "Any blockers?", "On it!",
    "Sounds good!", "Makes sense", "Agreed!", "For sure!",
    "Ha ha!", "No way!", "Really?", "Cool!", "Nice!", "Yep!",
    "Same here", "Totally", "Right?", "Indeed", "Oh yeah"
  ];

  // Boss speech phrases
  const BOSS_PHRASES = [
    "Q4 numbers!", "Synergy!", "Circle back!", "Let's pivot!",
    "Action items!", "Deep dive!", "Touch base!", "EOD please!",
    "Per my email...", "Going forward...", "Best practices!", "KPIs!",
    "Bandwidth?", "Low-hanging fruit!", "Move the needle!", "Win-win!"
  ];

  // NPC class for boss and secretary
  class NPC {
    constructor(deskIndex, name) {
      this.deskIndex = deskIndex;
      this.name = name;
      const desk = DESKS[deskIndex];
      // Center character based on desk type
      const xOffset = desk.type === 'executive' ? 55 : desk.type === 'secretary' ? 50 : 40;
      this.x = desk.x + xOffset;
      this.y = desk.y - 35;
      this.floor = desk.floor;
      this.targetX = this.x;
      this.targetY = this.y;
      this.state = 'working'; // working, wandering
      this.activity = 'typing'; // typing, thinking, phone, reviewing
      this.hair = name === 'Boss' ? '#404040' : '#c08040'; // Gray for boss, blonde for secretary
      this.shirt = name === 'Boss' ? '#1a1a3a' : '#d04080'; // Dark suit for boss, pink for secretary
      this.frame = Math.random() * 100;
      this.wanderTimer = 300 + Math.random() * 600;
      this.activityTimer = 100 + Math.random() * 200;
      this.facingRight = true;
      this.speechBubble = null;
      this.speechTimer = 0;
      this.greetedSessions = new Set(); // Track who secretary has greeted
    }

    getDesk() {
      return DESKS[this.deskIndex];
    }

    update() {
      this.frame++;
      const desk = this.getDesk();
      // Center character based on desk type
      const xOffset = desk.type === 'executive' ? 55 : desk.type === 'secretary' ? 50 : 40;
      const deskX = desk.x + xOffset;
      const deskY = desk.y - 35;

      // Speech bubble timer
      if (this.speechTimer > 0) {
        this.speechTimer--;
        if (this.speechTimer <= 0) {
          this.speechBubble = null;
        }
      }

      // Boss activities and speech
      if (this.name === 'Boss' && this.state === 'working' && !this.isWalking()) {
        this.activityTimer--;
        if (this.activityTimer <= 0) {
          // Change activity
          const activities = ['typing', 'typing', 'thinking', 'phone', 'reviewing'];
          this.activity = activities[Math.floor(Math.random() * activities.length)];
          this.activityTimer = 150 + Math.random() * 300;

          // Random chance to say something
          if (Math.random() < 0.4) {
            this.speechBubble = BOSS_PHRASES[Math.floor(Math.random() * BOSS_PHRASES.length)];
            this.speechTimer = 120;
          }
        }
      }

      // Secretary greetings - detect passing characters
      if (this.name === 'Secretary' && this.state === 'working') {
        const secretaryX = this.x;
        sessions.forEach(s => {
          const char = s.character;
          const charX = char.x;
          const nearSecretary = Math.abs(charX - secretaryX) < 80 && char.floor === 1;

          if (nearSecretary && !this.greetedSessions.has(s.id)) {
            // Character is passing by - greet them
            if (char.state === 'entering') {
              this.speechBubble = ['Welcome!', 'Hello!', 'Hi there!', 'Good morning!'][Math.floor(Math.random() * 4)];
            } else if (char.state === 'leaving') {
              this.speechBubble = ['Goodbye!', 'Bye!', 'See you!', 'Take care!'][Math.floor(Math.random() * 4)];
            }
            if (this.speechBubble) {
              this.speechTimer = 90;
              this.greetedSessions.add(s.id);
              // Clear after a delay so they can be greeted again
              setTimeout(() => this.greetedSessions.delete(s.id), 5000);
            }
          }
        });
      }

      this.wanderTimer--;
      if (this.wanderTimer <= 0) {
        if (this.state === 'working') {
          // Occasionally get up and wander
          if (Math.random() < 0.3) {
            this.state = 'wandering';
            // Pick a nearby point to wander to (within bounds)
            const wanderDist = 50 + Math.random() * 100;
            let newX = deskX + (Math.random() > 0.5 ? wanderDist : -wanderDist);
            // Keep within building bounds
            const minX = desk.type === 'executive' ? STAIRS_X + 100 : BUILDING_LEFT + 30;
            const maxX = desk.type === 'executive' ? BUILDING_RIGHT - 40 : STAIRS_X - 30;
            newX = Math.max(minX, Math.min(maxX, newX));
            this.targetX = newX;
            this.targetY = deskY;
            this.wanderTimer = 100 + Math.random() * 150;
          } else {
            this.wanderTimer = 200 + Math.random() * 400;
          }
        } else {
          // Return to desk
          this.state = 'working';
          this.targetX = deskX;
          this.targetY = deskY;
          this.wanderTimer = 300 + Math.random() * 600;
        }
      }

      // Movement
      const dx = this.targetX - this.x;
      const dy = this.targetY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > 3) {
        const speed = 1.5;
        this.x += (dx / dist) * speed;
        this.y += (dy / dist) * speed;
        this.facingRight = dx > 0;
      }
    }

    isWalking() {
      const dx = this.targetX - this.x;
      const dy = this.targetY - this.y;
      return Math.sqrt(dx * dx + dy * dy) > 5;
    }

    draw() {
      const x = Math.floor(this.x);
      const y = Math.floor(this.y);
      const walking = this.isWalking();
      const bounce = walking ? Math.sin(this.frame * 0.3) * 2 : 0;
      const isWorking = this.state === 'working' && !walking;
      const typingBounce = isWorking && this.activity === 'typing' ? Math.sin(this.frame * 0.15) : 0;

      // Shadow
      ctx.fillStyle = C.shadow;
      ctx.beginPath();
      ctx.ellipse(x, y + 36, 12, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Legs
      rect(x - 6, y + 22 + bounce, 5, 12, '#404060');
      rect(x + 1, y + 22 + bounce, 5, 12, '#404060');

      // Body
      rect(x - 8, y + 4 + bounce + typingBounce, 16, 20, this.shirt);

      // Arms based on activity
      if (isWorking) {
        if (this.activity === 'typing') {
          const armAnim = Math.floor(this.frame / 8) % 2;
          rect(x - 12, y + 8 + typingBounce + armAnim, 6, 12, C.skin);
          rect(x + 6, y + 8 + typingBounce + (1 - armAnim), 6, 12, C.skin);
        } else if (this.activity === 'thinking') {
          // Hand on chin
          rect(x - 12, y + 10, 6, 10, C.skin);
          rect(x + 6, y + 2, 6, 14, C.skin);
        } else if (this.activity === 'phone') {
          // One arm up holding phone
          rect(x - 12, y + 8, 6, 12, C.skin);
          rect(x + 6, y - 4, 6, 18, C.skin);
          // Phone
          rect(x + 8, y - 8, 4, 10, '#202020');
        } else if (this.activity === 'reviewing') {
          // Arms down looking at papers
          rect(x - 12, y + 12, 6, 10, C.skin);
          rect(x + 6, y + 12, 6, 10, C.skin);
        } else {
          rect(x - 12, y + 8, 6, 12, C.skin);
          rect(x + 6, y + 8, 6, 12, C.skin);
        }
      } else {
        rect(x - 12, y + 8 + bounce, 6, 12, C.skin);
        rect(x + 6, y + 8 + bounce, 6, 12, C.skin);
      }

      // Head
      rect(x - 8, y - 14 + bounce + typingBounce, 16, 18, C.skin);

      // Hair
      rect(x - 9, y - 18 + bounce + typingBounce, 18, 8, this.hair);
      rect(x - 10, y - 14 + bounce + typingBounce, 3, 8, this.hair);
      rect(x + 7, y - 14 + bounce + typingBounce, 3, 8, this.hair);

      // Eyes - look up when thinking
      const eyeY = (isWorking && this.activity === 'thinking') ? y - 10 : y - 8;
      rect(x - 5, eyeY + bounce + typingBounce, 3, 3, '#000');
      rect(x + 2, eyeY + bounce + typingBounce, 3, 3, '#000');

      // Activity indicators
      if (isWorking && this.name === 'Boss') {
        if (this.activity === 'typing') {
          // Code icon
          rect(x - 8, y - 32, 16, 10, '#40ff80');
          ctx.fillStyle = '#000';
          ctx.font = '8px monospace';
          ctx.fillText('</>', x - 7, y - 24);
        } else if (this.activity === 'thinking') {
          // Thought bubble
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 2;
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(x + 16, y - 20, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x + 24, y - 28, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x + 36, y - 38, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#333';
          ctx.font = 'bold 10px monospace';
          ctx.fillText('$', x + 32, y - 35);
        } else if (this.activity === 'reviewing') {
          // Document icon
          rect(x - 6, y - 32, 12, 14, '#fff');
          rect(x - 4, y - 29, 8, 2, '#333');
          rect(x - 4, y - 25, 6, 2, '#333');
          rect(x - 4, y - 21, 7, 2, '#333');
        }
      }

      // Speech bubble
      if (this.speechBubble && this.speechTimer > 0) {
        const bubbleWidth = Math.max(60, this.speechBubble.length * 7 + 16);
        const bubbleX = x - bubbleWidth / 2;
        const bubbleY = y - 55;

        // Bubble background
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(bubbleX, bubbleY, bubbleWidth, 22, 6);
        ctx.fill();
        ctx.stroke();

        // Bubble tail
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(x - 5, bubbleY + 22);
        ctx.lineTo(x + 5, bubbleY + 22);
        ctx.lineTo(x, bubbleY + 30);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(x - 5, bubbleY + 21);
        ctx.lineTo(x, bubbleY + 30);
        ctx.lineTo(x + 5, bubbleY + 21);
        ctx.stroke();

        // Text
        ctx.fillStyle = '#333';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.speechBubble, x, bubbleY + 15);
        ctx.textAlign = 'left';
      }
    }
  }

  // Create NPCs
  const npcs = [
    new NPC(5, 'Boss'),      // Executive desk
    new NPC(6, 'Secretary'), // Secretary desk
  ];

  function rect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
  }

  // ============ DRAWING ============

  function drawSky() {
    const grad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
    grad.addColorStop(0, C.sky);
    grad.addColorStop(0.7, C.skyBottom);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, GROUND_Y);

    // Sun
    ctx.fillStyle = '#fff8c0';
    ctx.beginPath();
    ctx.arc(100, 80, 40, 0, Math.PI * 2);
    ctx.fill();

    // Clouds
    drawCloud(180, 60, 1);
    drawCloud(500, 40, 0.8);
    drawCloud(900, 70, 1.2);
    drawCloud(1150, 50, 0.7);
  }

  function drawCloud(x, y, scale) {
    const offset = (frame * 0.1 + x) % (W + 200) - 100;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(offset, y, 40 * scale, 20 * scale, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(offset - 30 * scale, y + 10 * scale, 25 * scale, 15 * scale, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(offset + 35 * scale, y + 8 * scale, 28 * scale, 16 * scale, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawGround() {
    // Full grass background first
    rect(0, GROUND_Y, W, H - GROUND_Y, C.grass);

    // Sidewalk in front of building
    rect(BUILDING_LEFT - 40, GROUND_Y, BUILDING_RIGHT - BUILDING_LEFT + 80, 50, C.sidewalk);
    // Sidewalk edge/curb
    rect(BUILDING_LEFT - 40, GROUND_Y + 48, BUILDING_RIGHT - BUILDING_LEFT + 80, 4, '#a0a090');

    // Road at bottom
    rect(0, GROUND_Y + 52, W, H - GROUND_Y - 52, C.road);

    // Road center lines
    for (let x = 0; x < W; x += 60) {
      rect(x + 10, GROUND_Y + 75, 35, 5, C.roadLine);
    }

    // Grass texture (only on grass areas, not every frame - use seeded positions)
    ctx.fillStyle = C.grassDark;
    for (let i = 0; i < 40; i++) {
      const seed = i * 137.5;
      const gx = (seed * 7) % BUILDING_LEFT;
      const gy = GROUND_Y + 5 + (seed * 3) % 40;
      if (gy < GROUND_Y + 48) rect(gx, gy, 2, 5, C.grassDark);
    }
    for (let i = 0; i < 30; i++) {
      const seed = i * 173.3;
      const gx = BUILDING_RIGHT + (seed * 7) % (W - BUILDING_RIGHT);
      const gy = GROUND_Y + 5 + (seed * 3) % 40;
      if (gy < GROUND_Y + 48) rect(gx, gy, 2, 5, C.grassDark);
    }
  }

  function drawBush(x, y, size = 1) {
    ctx.fillStyle = C.bushDark;
    ctx.beginPath();
    ctx.ellipse(x, y, 25 * size, 18 * size, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = C.bushMid;
    ctx.beginPath();
    ctx.ellipse(x - 10 * size, y - 6 * size, 15 * size, 12 * size, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = C.bushLight;
    ctx.beginPath();
    ctx.ellipse(x + 8 * size, y - 4 * size, 12 * size, 10 * size, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawTree(x, y) {
    // Trunk
    rect(x - 12, y, 24, 80, C.treeTrunk);
    rect(x - 8, y + 80, 16, 20, C.treeTrunk);

    // Foliage
    ctx.fillStyle = C.bushDark;
    ctx.beginPath();
    ctx.ellipse(x, y - 30, 50, 55, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = C.bushMid;
    ctx.beginPath();
    ctx.ellipse(x - 25, y - 20, 35, 40, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x + 20, y - 35, 30, 35, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = C.bushLight;
    ctx.beginPath();
    ctx.ellipse(x - 10, y - 50, 25, 28, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawBuildingExterior() {
    // Main building base color
    rect(BUILDING_LEFT, BUILDING_TOP, BUILDING_RIGHT - BUILDING_LEFT, GROUND_Y - BUILDING_TOP, '#E8DCC8');

    // Subtle brick pattern - less busy
    for (let by = BUILDING_TOP; by < GROUND_Y; by += 16) {
      const rowOffset = ((by / 16) % 2) * 20;
      for (let bx = BUILDING_LEFT; bx < BUILDING_RIGHT; bx += 40) {
        // Subtle brick shading
        const shade = ((bx + by) % 80 < 40) ? '#E0D4C0' : '#D8CCB8';
        rect(bx + rowOffset, by, 38, 14, shade);
      }
      // Horizontal mortar line
      rect(BUILDING_LEFT, by + 14, BUILDING_RIGHT - BUILDING_LEFT, 2, '#D0C8B8');
    }

    // Building corner trim - subtle
    rect(BUILDING_LEFT, BUILDING_TOP, 6, GROUND_Y - BUILDING_TOP, '#C8BCA8');
    rect(BUILDING_RIGHT - 6, BUILDING_TOP, 6, GROUND_Y - BUILDING_TOP, '#C8BCA8');

    // Floor divider line on exterior (between 1st and 2nd floor)
    rect(BUILDING_LEFT, FLOOR_DIVIDER, BUILDING_RIGHT - BUILDING_LEFT, 8, '#B0A498');
    rect(BUILDING_LEFT, FLOOR_DIVIDER + 6, BUILDING_RIGHT - BUILDING_LEFT, 4, '#A09488');

    // Roof with overhang
    rect(BUILDING_LEFT - 20, BUILDING_TOP - 30, BUILDING_RIGHT - BUILDING_LEFT + 40, 35, C.roofDark);
    rect(BUILDING_LEFT - 15, BUILDING_TOP - 25, BUILDING_RIGHT - BUILDING_LEFT + 30, 25, C.roofLight);
    // Roof trim
    rect(BUILDING_LEFT - 20, BUILDING_TOP - 5, BUILDING_RIGHT - BUILDING_LEFT + 40, 8, '#5a5a6a');

    // Sign on roof - nicer styling
    const signText = officeTitle.toUpperCase();
    const signWidth = Math.max(200, signText.length * 14 + 40);
    const signX = 640 - signWidth / 2;
    rect(signX, BUILDING_TOP - 65, signWidth, 45, '#2c3e50');
    rect(signX + 5, BUILDING_TOP - 60, signWidth - 10, 35, '#34495e');
    ctx.fillStyle = '#ECF0F1';
    ctx.font = 'bold 22px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(signText, 640, BUILDING_TOP - 35);
    ctx.textAlign = 'left';
  }

  function drawInterior() {
    // Interior wall (visible through cutaway)
    rect(BUILDING_LEFT + 10, BUILDING_TOP + 10, BUILDING_RIGHT - BUILDING_LEFT - 20, GROUND_Y - BUILDING_TOP - 20, C.wallInterior);

    // === FLOOR DIVIDER (between 1st and 2nd floor) ===
    rect(BUILDING_LEFT + 10, FLOOR_DIVIDER, STAIRS_X - BUILDING_LEFT - 10, 14, '#8B7355');
    rect(STAIRS_X + 80, FLOOR_DIVIDER, BUILDING_RIGHT - STAIRS_X - 90, 14, '#8B7355');

    // === SECOND FLOOR LEFT (Office area - workstations) ===
    // Wood floor background
    rect(BUILDING_LEFT + 10, BUILDING_TOP + 10, STAIRS_X - BUILDING_LEFT - 10, FLOOR_DIVIDER - BUILDING_TOP - 10, C.floorWood);

    // Wood floor planks
    for (let fy = BUILDING_TOP + 15; fy < FLOOR_DIVIDER; fy += 12) {
      for (let fx = BUILDING_LEFT + 10; fx < STAIRS_X - 5; fx += 60) {
        const shade = ((fx + fy) % 120 < 60) ? C.floorWoodLight : C.floorWoodDark;
        rect(fx, fy, 58, 10, shade);
      }
      // Plank gap line
      rect(BUILDING_LEFT + 10, fy + 10, STAIRS_X - BUILDING_LEFT - 15, 2, '#C09060');
    }

    // 2nd floor office windows (in the back wall)
    drawWindow(280, BUILDING_TOP + 25);
    drawWindow(480, BUILDING_TOP + 25);
    drawWindow(680, BUILDING_TOP + 25);

    // Whiteboard in office area (centered between first two windows)
    drawWhiteboard(370, BUILDING_TOP + 40);

    // Water cooler is drawn separately in drawWaterCooler() for proper layering

    // === SECOND FLOOR RIGHT (Executive Office) ===
    // Fancy carpet floor
    rect(STAIRS_X + 80, BUILDING_TOP + 10, BUILDING_RIGHT - STAIRS_X - 90, FLOOR_DIVIDER - BUILDING_TOP - 10, '#8B4513');
    // Carpet pattern
    for (let fy = BUILDING_TOP + 20; fy < FLOOR_DIVIDER - 10; fy += 20) {
      for (let fx = STAIRS_X + 90; fx < BUILDING_RIGHT - 20; fx += 20) {
        rect(fx, fy, 16, 16, '#7B3A0A');
      }
    }
    // Carpet border
    rect(STAIRS_X + 85, BUILDING_TOP + 15, BUILDING_RIGHT - STAIRS_X - 95, 5, '#5C2D0A');
    rect(STAIRS_X + 85, FLOOR_DIVIDER - 20, BUILDING_RIGHT - STAIRS_X - 95, 5, '#5C2D0A');

    // Executive office window (big window)
    drawWindow(1000, BUILDING_TOP + 25);

    // Bookshelf in executive office
    rect(STAIRS_X + 95, BUILDING_TOP + 30, 50, 100, '#5C4033');
    rect(STAIRS_X + 98, BUILDING_TOP + 35, 44, 18, '#8B7355');
    rect(STAIRS_X + 98, BUILDING_TOP + 58, 44, 18, '#8B7355');
    rect(STAIRS_X + 98, BUILDING_TOP + 81, 44, 18, '#8B7355');
    // Books
    rect(STAIRS_X + 100, BUILDING_TOP + 37, 8, 14, '#c04040');
    rect(STAIRS_X + 110, BUILDING_TOP + 37, 6, 14, '#4040c0');
    rect(STAIRS_X + 118, BUILDING_TOP + 37, 10, 14, '#40a040');
    rect(STAIRS_X + 100, BUILDING_TOP + 60, 12, 14, '#c0a040');
    rect(STAIRS_X + 114, BUILDING_TOP + 60, 8, 14, '#a040a0');

    // Potted plant in executive office
    drawPlant(BUILDING_RIGHT - 50, FLOOR_DIVIDER - 35);

    // === STAIRWELL ===
    // Stairwell shaft background (full height)
    rect(STAIRS_X, BUILDING_TOP + 10, 80, GROUND_Y - BUILDING_TOP - 25, '#D0C8C0');

    // 2nd floor landing platform (top of stairs)
    rect(STAIRS_X + 5, CHAR_FLOOR_2_Y + 20, 70, 12, C.floorWood);

    // Draw stairs connecting floors (going down from 2nd floor to 1st floor)
    const stairTopY = CHAR_FLOOR_2_Y + 30;  // Just below 2nd floor
    const stairBottomY = CHAR_FLOOR_1_Y - 10; // Just above 1st floor
    const numStairs = 14;
    const stairHeight = (stairBottomY - stairTopY) / numStairs;
    const stairWidth = 50;

    for (let i = 0; i < numStairs; i++) {
      const stairY = stairTopY + (i * stairHeight);
      const stairX = STAIRS_X + 15;

      // Step surface (top)
      rect(stairX, stairY, stairWidth, 6, '#B8B0A8');
      // Step riser (front)
      rect(stairX, stairY + 4, stairWidth, stairHeight - 2, '#908880');
    }

    // 1st floor landing platform (bottom of stairs)
    rect(STAIRS_X + 5, CHAR_FLOOR_1_Y - 5, 70, 12, '#E0D8D0');

    // Stair railings
    rect(STAIRS_X + 10, stairTopY - 30, 4, stairBottomY - stairTopY + 40, '#5C4033');
    rect(STAIRS_X + 68, stairTopY - 30, 4, stairBottomY - stairTopY + 40, '#5C4033');

    // Railing top caps
    rect(STAIRS_X + 8, stairTopY - 35, 8, 8, '#6B5040');
    rect(STAIRS_X + 66, stairTopY - 35, 8, 8, '#6B5040');


    // === FIRST FLOOR ===
    // Lobby floor (left side) - nice tiles
    for (let fy = FLOOR_DIVIDER + 14; fy < GROUND_Y - 15; fy += 25) {
      for (let fx = BUILDING_LEFT + 10; fx < DIVIDER_X - 5; fx += 25) {
        const shade = ((fx + fy) / 25) % 2 === 0 ? '#E8E0D8' : '#DDD5CD';
        rect(fx, fy, 24, 24, shade);
      }
    }

    // Break room floor (right side of divider, left of stairs) - cyan tiles
    for (let fy = FLOOR_DIVIDER + 14; fy < GROUND_Y - 15; fy += 30) {
      for (let fx = DIVIDER_X + 10; fx < STAIRS_X; fx += 30) {
        const shade = ((fx + fy) / 30) % 2 === 0 ? C.tileCyan : C.tileCyanDark;
        rect(fx, fy, 28, 28, shade);
      }
    }

    // Right side of stairwell floor (break room continues)
    for (let fy = FLOOR_DIVIDER + 14; fy < GROUND_Y - 15; fy += 30) {
      for (let fx = STAIRS_X + 80; fx < BUILDING_RIGHT - 10; fx += 30) {
        const shade = ((fx + fy) / 30) % 2 === 0 ? C.tileCyan : C.tileCyanDark;
        rect(fx, fy, 28, 28, shade);
      }
    }

    // 1st floor windows
    drawWindow(350, FLOOR_DIVIDER + 50);
    drawWindow(530, FLOOR_DIVIDER + 50);

    // Divider wall between lobby and break room (1st floor only)
    rect(DIVIDER_X - 5, FLOOR_DIVIDER + 14, 10, GROUND_Y - FLOOR_DIVIDER - 30, C.wallTrim);
    // Doorway in divider
    rect(DIVIDER_X - 5, FLOOR_1_Y - 80, 10, 80, C.wallInterior);
    rect(DIVIDER_X - 6, FLOOR_1_Y - 84, 12, 6, C.doorFrame);

    // Entrance door (on left SIDE of building - viewed from side)
    const doorY = GROUND_Y - 15;
    // Door is on the side wall, so we see it edge-on
    rect(BUILDING_LEFT - 5, doorY - 80, 15, 85, C.doorFrame);
    rect(BUILDING_LEFT - 3, doorY - 75, 11, 78, C.door);
    // Door handle
    rect(BUILDING_LEFT + 5, doorY - 40, 4, 8, C.doorHandle);

    // Plants in lobby (secretary desk is drawn separately)
    drawPlant(340, GROUND_Y - 35);
    drawPlant(580, GROUND_Y - 35);

    // Welcome mat at side entrance
    rect(BUILDING_LEFT - 10, GROUND_Y - 12, 30, 15, '#4a6a4a');
  }

  function drawWindow(x, y) {
    rect(x, y, 80, 70, C.windowFrame);
    rect(x + 5, y + 5, 70, 60, C.windowGlass);
    rect(x + 38, y + 5, 4, 60, C.windowFrame);
    rect(x + 5, y + 32, 70, 4, C.windowFrame);
  }

  function drawWhiteboard(x, y) {
    rect(x, y, 100, 60, '#707070');
    rect(x + 4, y + 4, 92, 52, '#f8f8f8');
    // Some content
    rect(x + 10, y + 12, 40, 3, '#4080d0');
    rect(x + 10, y + 20, 60, 3, '#40a040');
    rect(x + 10, y + 28, 30, 3, '#d04080');
    rect(x + 60, y + 35, 25, 18, '#404060');
  }

  function drawDeskBackground(desk, index) {
    // Chairs removed - no background elements needed
  }

  function drawDeskForeground(desk, index) {
    // Draw desk surface, monitor, keyboard (in front of character)
    const x = desk.x;
    const y = desk.y;
    const type = desk.type || 'workstation';

    // Check if this desk is active
    let isActive = false;
    const session = sessions.find(s => s.character.deskIndex === index);
    if (session && session.character.actualState === 'typing' && session.character.state === 'working') {
      isActive = true;
    }

    if (type === 'executive') {
      drawExecutiveDeskForeground(x, y, isActive);
    } else if (type === 'secretary') {
      drawSecretaryDeskForeground(x, y, isActive);
    } else {
      drawWorkstationDeskForeground(x, y, isActive);
    }
  }

  function drawWorkstationChair(x, y) {
    // Chair behind desk (above desk, smaller y) - drawn BEFORE character
    const chairY = y - 45;
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(x + 40, chairY + 28, 20, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    // Chair back (visible behind character)
    rect(x + 26, chairY - 5, 28, 25, C.chairBlueDark);
    rect(x + 28, chairY - 3, 24, 20, C.chairBlue);
    // Seat
    rect(x + 26, chairY + 18, 28, 14, C.chairBlue);
    rect(x + 28, chairY + 20, 24, 10, C.chairBlueLight);
    // Chair base
    rect(x + 38, chairY + 30, 4, 8, '#303030');
  }

  function drawWorkstationDeskForeground(x, y, isActive) {
    // Desk and monitor drawn AFTER character (in front)

    // Desk shadow
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(x + 40, y + 35, 45, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Desk surface
    rect(x, y, 80, 6, C.deskTop);
    rect(x + 2, y + 6, 76, 14, C.deskFront);
    rect(x, y + 18, 80, 5, '#A08060');

    // Legs
    rect(x + 6, y + 23, 6, 18, C.deskLeg);
    rect(x + 68, y + 23, 6, 18, C.deskLeg);

    // Monitor ON the desk (back of monitor facing us)
    const monY = y - 28;
    // Monitor back (dark gray/black - what we see)
    rect(x + 22, monY, 40, 30, '#2a2a2a');
    rect(x + 24, monY + 2, 36, 26, '#1a1a1a');
    // Ventilation slots on back
    for (let i = 0; i < 4; i++) {
      rect(x + 28 + i * 8, monY + 8, 5, 12, '#222');
    }
    // Monitor stand
    rect(x + 38, monY + 28, 8, 8, '#404048');
    rect(x + 34, y - 4, 16, 6, '#505058');

    // Keyboard on desk (in front of monitor)
    rect(x + 24, y + 2, 36, 8, '#303038');
    rect(x + 26, y + 3, 32, 5, '#404048');
  }

  function drawExecutiveChair(x, y) {
    // Executive leather chair BEHIND desk - drawn BEFORE character
    const chairY = y - 55;
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(x + 55, chairY + 35, 28, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    // High back (visible behind character)
    rect(x + 30, chairY - 10, 50, 35, '#1a1a1a');
    rect(x + 33, chairY - 7, 44, 28, '#2a2a2a');
    // Seat
    rect(x + 30, chairY + 22, 50, 18, '#1a1a1a');
    rect(x + 33, chairY + 24, 44, 12, '#2a2a2a');
    // Arm rests
    rect(x + 23, chairY + 15, 10, 16, '#1a1a1a');
    rect(x + 77, chairY + 15, 10, 16, '#1a1a1a');
    // Chair base
    rect(x + 52, chairY + 38, 6, 10, '#404040');
  }

  function drawExecutiveDeskForeground(x, y, isActive) {
    // Desk and monitors drawn AFTER character (in front)

    // Big fancy executive desk - darker wood
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(x + 55, y + 40, 60, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Large desk surface - rich mahogany color
    rect(x, y, 110, 8, '#5C3A21');
    rect(x + 2, y + 8, 106, 16, '#4A2F1A');
    rect(x, y + 22, 110, 6, '#3D2515');

    // Desk front panel details
    rect(x + 10, y + 10, 35, 12, '#3D2515');
    rect(x + 65, y + 10, 35, 12, '#3D2515');

    // Gold drawer handles
    rect(x + 22, y + 14, 10, 4, '#DAA520');
    rect(x + 78, y + 14, 10, 4, '#DAA520');

    // Sturdy legs
    rect(x + 8, y + 28, 10, 16, '#3D2515');
    rect(x + 92, y + 28, 10, 16, '#3D2515');

    // Dual monitors ON desk (back of monitors facing us)
    const monY = y - 30;
    // Left monitor back
    rect(x + 12, monY, 38, 32, '#2a2a2a');
    rect(x + 14, monY + 2, 34, 28, '#1a1a1a');
    // Ventilation slots
    for (let i = 0; i < 3; i++) {
      rect(x + 18 + i * 10, monY + 8, 6, 14, '#222');
    }
    // Right monitor back
    rect(x + 60, monY, 38, 32, '#2a2a2a');
    rect(x + 62, monY + 2, 34, 28, '#1a1a1a');
    // Ventilation slots
    for (let i = 0; i < 3; i++) {
      rect(x + 66 + i * 10, monY + 8, 6, 14, '#222');
    }

    // Monitor stands
    rect(x + 26, monY + 30, 10, 8, '#404048');
    rect(x + 74, monY + 30, 10, 8, '#404048');
    rect(x + 22, y - 4, 18, 6, '#505058');
    rect(x + 70, y - 4, 18, 6, '#505058');

    // Keyboard on desk (between monitors)
    rect(x + 35, y + 2, 40, 10, '#202028');
    rect(x + 37, y + 3, 36, 7, '#303038');

    // Name plate on front of desk
    rect(x + 42, y + 24, 26, 6, '#DAA520');
    ctx.fillStyle = '#000';
    ctx.font = '5px monospace';
    ctx.fillText('BOSS', x + 46, y + 29);
  }

  function drawSecretaryChair(x, y) {
    // Chair BEHIND desk - drawn BEFORE character
    const chairY = y - 40;
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(x + 50, chairY + 28, 18, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    // Chair back
    rect(x + 34, chairY - 5, 32, 22, C.chairBlueDark);
    rect(x + 36, chairY - 3, 28, 18, C.chairBlue);
    // Seat
    rect(x + 34, chairY + 15, 32, 14, C.chairBlue);
    rect(x + 36, chairY + 17, 28, 10, C.chairBlueLight);
    rect(x + 48, chairY + 27, 4, 8, '#303030');
  }

  function drawSecretaryDeskForeground(x, y, isActive) {
    // Desk and monitor drawn AFTER character (in front)

    // Reception-style desk shadow
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(x + 50, y + 32, 55, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Desk surface - lighter wood
    rect(x, y, 100, 6, '#D4A574');
    rect(x + 2, y + 6, 96, 12, '#C49464');
    rect(x, y + 16, 100, 5, '#B48454');

    // Front panel
    rect(x + 10, y + 8, 80, 8, '#A47444');

    // Legs
    rect(x + 8, y + 21, 6, 16, '#8B7355');
    rect(x + 86, y + 21, 6, 16, '#8B7355');

    // Monitor ON desk (back facing us)
    const monY = y - 26;
    rect(x + 32, monY, 36, 28, '#2a2a2a');
    rect(x + 34, monY + 2, 32, 24, '#1a1a1a');
    // Ventilation slots
    for (let i = 0; i < 3; i++) {
      rect(x + 38 + i * 8, monY + 6, 5, 12, '#222');
    }
    // Monitor stand
    rect(x + 46, monY + 26, 8, 6, '#404048');
    rect(x + 42, y - 4, 16, 6, '#505058');

    // Keyboard on desk
    rect(x + 34, y + 2, 32, 8, '#303038');
    rect(x + 36, y + 3, 28, 5, '#404048');

    // Phone on desk
    rect(x + 75, y + 2, 18, 8, '#202020');
    rect(x + 77, y + 3, 14, 4, '#404050');
  }

  function drawBreakRoom() {
    // Break room is on the right side of the stairwell on floor 1
    const floorY = GROUND_Y - 20;  // Floor level
    const breakRoomLeft = STAIRS_X + 95;

    // Couch (all items aligned to same floor level)
    rect(breakRoomLeft, floorY - 35, 90, 28, '#506090');  // Couch base
    rect(breakRoomLeft, floorY - 55, 90, 22, '#405080');  // Couch back
    rect(breakRoomLeft + 5, floorY - 33, 25, 24, '#607098');  // Cushion 1
    rect(breakRoomLeft + 35, floorY - 33, 25, 24, '#607098'); // Cushion 2
    rect(breakRoomLeft + 65, floorY - 33, 20, 24, '#607098'); // Cushion 3

    // Coffee table (in front of couch)
    rect(breakRoomLeft + 15, floorY - 8, 55, 12, C.deskFront);
    rect(breakRoomLeft + 15, floorY - 12, 55, 5, C.deskTop);
    // Table legs
    rect(breakRoomLeft + 18, floorY + 2, 4, 8, C.deskLeg);
    rect(breakRoomLeft + 64, floorY + 2, 4, 8, C.deskLeg);

    // Vending machine (against right wall, same floor)
    const vmX = BUILDING_RIGHT - 65;
    rect(vmX, floorY - 80, 45, 80, '#4060a0');  // Body
    rect(vmX + 4, floorY - 75, 37, 45, '#203050');  // Display area
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 3; col++) {
        const colors = ['#ff6060', '#60ff60', '#6060ff', '#ffff60', '#ff60ff', '#60ffff'];
        rect(vmX + 8 + col * 11, floorY - 70 + row * 13, 8, 10, colors[(row * 3 + col) % 6]);
      }
    }
    rect(vmX + 4, floorY - 25, 37, 20, '#102030');  // Bottom slot

    // Coffee station (counter with coffee maker)
    const cmX = breakRoomLeft + 100;
    rect(cmX, floorY - 40, 40, 28, C.deskFront);  // Counter
    rect(cmX, floorY - 45, 40, 6, C.deskTop);     // Counter top
    rect(cmX + 5, floorY + 2, 4, 10, C.deskLeg);  // Counter legs
    rect(cmX + 31, floorY + 2, 4, 10, C.deskLeg);
    // Coffee maker on counter
    rect(cmX + 8, floorY - 70, 24, 26, '#303040');
    rect(cmX + 11, floorY - 66, 18, 14, '#505060');
    if (frame % 60 < 30) {
      rect(cmX + 27, floorY - 68, 4, 4, '#ff4040');  // Power light
    }

    // Plant in break room
    drawPlant(breakRoomLeft - 15, floorY - 8);

    // Window in break room
    drawWindow(STAIRS_X + 130, FLOOR_DIVIDER + 50);
  }

  function drawPlant(x, y) {
    rect(x, y, 20, 18, C.pot);
    rect(x + 3, y - 3, 14, 5, C.pot);
    rect(x + 6, y - 25, 8, 25, C.plantGreen);
    rect(x - 4, y - 15, 10, 15, C.plantDark);
    rect(x + 14, y - 20, 10, 18, C.plantGreen);
    rect(x + 2, y - 35, 16, 15, C.plantDark);
  }

  function drawWaterCooler() {
    // Water cooler on 2nd floor - drawn AFTER characters for proper layering
    rect(750, FLOOR_DIVIDER - 70, 25, 55, '#a0d8e8');
    rect(750, FLOOR_DIVIDER - 80, 25, 15, '#4080a0');
    rect(757, FLOOR_DIVIDER - 20, 11, 8, '#404040');
  }

  function drawExteriorDetails() {
    // Lamp post
    rect(170, GROUND_Y - 120, 8, 120, '#505050');
    rect(155, GROUND_Y - 130, 38, 15, '#606060');
    rect(162, GROUND_Y - 125, 24, 8, '#ffff80');
  }

  // ============ MAIN LOOP ============

  function render() {
    frame++;

    // Update all characters and NPCs
    sessions.forEach(s => s.character.update());
    npcs.forEach(npc => npc.update());

    // Remove finished leaving characters
    sessions = sessions.filter(s => {
      if (s.character.state === 'leaving' && s.character.x <= 55) {
        DESKS[s.character.deskIndex].occupied = false;
        return false;
      }
      return true;
    });

    // Clear
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    // Draw scene
    drawSky();
    // Trees drawn early so ground covers their bases
    drawTree(80, GROUND_Y - 80);
    drawTree(1200, GROUND_Y - 80);
    drawGround();
    drawBuildingExterior();
    drawInterior();

    // Draw desk backgrounds (chairs) - BEHIND characters
    DESKS.forEach((desk, i) => drawDeskBackground(desk, i));

    // Draw break room furniture BEFORE characters (background)
    drawBreakRoom();

    // Create drawable objects for characters and desk foregrounds, sorted by Y
    const drawables = [];

    // Add characters and NPCs
    sessions.forEach(s => drawables.push({ type: 'character', obj: s.character, y: s.character.y }));
    npcs.forEach(npc => drawables.push({ type: 'character', obj: npc, y: npc.y }));

    // Add desk foregrounds (use desk.y as the sort position)
    DESKS.forEach((desk, i) => drawables.push({ type: 'desk', desk: desk, index: i, y: desk.y }));

    // Sort by Y position (lower Y = further back, drawn first)
    drawables.sort((a, b) => a.y - b.y);

    // Draw everything in order
    drawables.forEach(d => {
      if (d.type === 'character') {
        d.obj.draw();
      } else if (d.type === 'desk') {
        drawDeskForeground(d.desk, d.index);
      }
    });

    // Draw water cooler after characters (foreground)
    drawWaterCooler();
    drawExteriorDetails();

    // Update UI
    document.getElementById('sessionCount').textContent =
      `${sessions.length} active session${sessions.length !== 1 ? 's' : ''}`;

    // Update session panel (throttled)
    if (frame % 30 === 0) {
      updateSessionPanel();
    }

    requestAnimationFrame(render);
  }

  function updateSessionPanel() {
    const listEl = document.getElementById('sessionList');
    if (sessions.length === 0) {
      listEl.innerHTML = '<div class="session-empty">No active sessions</div>';
      return;
    }

    listEl.innerHTML = sessions.map(s => {
      const c = s.character;
      const state = c.getDisplayState();
      const num = c.id + 1;
      const specialIcons = {
        alien: '', robot: '', werewolf: '', vampire: '', ninja: '', zombie: ''
      };
      const specialIcon = c.special ? specialIcons[c.special.type] || '' : '';
      return `
        <div class="session-item">
          <div class="session-number" style="background: ${c.shirt}">${num}</div>
          <div class="session-dot ${state}"></div>
          <div class="session-info">
            <div class="session-title">${specialIcon} ${escapeHtml(c.title)}</div>
            <div class="session-state">${state}</div>
          </div>
        </div>
      `;
    }).join('');
  }

  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // Start
  render();

  // ============ API ============

  let sessionIdCounter = 0;

  return {
    addSession(title = null) {
      // Find available desk
      const deskIndex = DESKS.findIndex(d => !d.occupied);
      if (deskIndex === -1) {
        console.log('All desks occupied!');
        return null;
      }

      DESKS[deskIndex].occupied = true;
      const id = sessionIdCounter++;
      const character = new Character(id, deskIndex, title);
      const session = { id, character };
      sessions.push(session);
      updateSessionPanel();
      console.log(`[PixelOffice] Session ${id} started: "${character.title}", desk ${deskIndex}`);
      return id;
    },

    setSessionTitle(title, id) {
      const session = id !== undefined
        ? sessions.find(s => s.id === id)
        : sessions[sessions.length - 1];
      if (session) {
        session.character.title = title;
        updateSessionPanel();
      }
    },

    removeSession(id) {
      // If no ID, remove most recent
      if (id === undefined) {
        if (sessions.length === 0) return;
        id = sessions[sessions.length - 1].id;
      }

      const session = sessions.find(s => s.id === id);
      if (session) {
        session.character.state = 'leaving';
        session.character.actualState = 'idle';
        console.log(`[PixelOffice] Session ${id} ending`);
      }
    },

    setSessionState(state, id) {
      // If no ID, affect most recent
      const session = id !== undefined
        ? sessions.find(s => s.id === id)
        : sessions[sessions.length - 1];

      if (session && session.character.state !== 'leaving') {
        // Reset thinking target when state changes
        if (session.character.actualState !== state) {
          session.character.thinkingTarget = undefined;
        }
        session.character.actualState = state;
        console.log(`[PixelOffice] Session ${session.id} state: ${state}`);
      }
    },

    getSessions() {
      return sessions.map(s => ({
        id: s.id,
        state: s.character.actualState,
        desk: s.character.deskIndex
      }));
    },

    // For external event integration
    onEvent(sessionId, eventType) {
      let session = sessions.find(s => s.id === sessionId);

      // Auto-create session if doesn't exist
      if (!session && eventType !== 'session_end') {
        const newId = this.addSession();
        if (newId !== null) {
          session = sessions.find(s => s.id === newId);
          // Use provided sessionId for tracking
          if (session) session.externalId = sessionId;
        }
      }

      if (!session) return;

      if (eventType === 'session_end') {
        this.removeSession(session.id);
      } else {
        const stateMap = {
          'edit': 'typing', 'write': 'typing', 'bash': 'typing',
          'read': 'thinking', 'grep': 'thinking', 'glob': 'thinking',
          'task': 'thinking', 'search': 'thinking',
          'idle': 'idle', 'done': 'idle'
        };
        this.setSessionState(stateMap[eventType] || 'idle', session.id);
      }
    }
  };
})();

// WebSocket connection
(function() {
  if (window.location.protocol === 'file:') return;

  const wsUrl = `ws://${window.location.hostname}:${window.location.port || 3456}`;
  let ws;
  const sessionMap = {}; // Map external session IDs to internal IDs
  const idleTimeouts = {}; // Track idle timeouts per session
  const IDLE_DELAY = 15000; // Wait 15 seconds after last tool_end before going idle

  function connect() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => console.log('[WS] Connected');
    ws.onmessage = (e) => {
      try {
        const event = JSON.parse(e.data);
        if (event.type === 'connected') return;

        const externalId = event.sessionId || 'default';
        const sessionTitle = event.title || event.cwd || externalId;

        if (event.type === 'session_end') {
          if (sessionMap[externalId] !== undefined) {
            // Clear any pending idle timeout
            if (idleTimeouts[externalId]) {
              clearTimeout(idleTimeouts[externalId]);
              delete idleTimeouts[externalId];
            }
            pixelOffice.removeSession(sessionMap[externalId]);
            delete sessionMap[externalId];
          }
        } else if (event.type === 'tool_start' || event.type === 'tool_end') {
          // Create session if needed
          if (sessionMap[externalId] === undefined) {
            const id = pixelOffice.addSession(sessionTitle);
            if (id !== null) sessionMap[externalId] = id;
          }

          // Update title if provided
          if (event.title) {
            pixelOffice.setSessionTitle(event.title, sessionMap[externalId]);
          }

          // Clear any pending idle timeout on new activity
          if (idleTimeouts[externalId]) {
            clearTimeout(idleTimeouts[externalId]);
            delete idleTimeouts[externalId];
          }

          if (event.type === 'tool_start') {
            const tool = (event.tool || '').toLowerCase();
            if (['edit', 'write', 'bash', 'notebookedit'].includes(tool)) {
              pixelOffice.setSessionState('typing', sessionMap[externalId]);
            } else {
              pixelOffice.setSessionState('thinking', sessionMap[externalId]);
            }
          } else {
            // tool_end: stay in thinking state, schedule idle after delay
            pixelOffice.setSessionState('thinking', sessionMap[externalId]);
            idleTimeouts[externalId] = setTimeout(() => {
              pixelOffice.setSessionState('idle', sessionMap[externalId]);
              delete idleTimeouts[externalId];
            }, IDLE_DELAY);
          }
        }
      } catch (err) {}
    };
    ws.onclose = () => setTimeout(connect, 2000);
    ws.onerror = () => ws.close();
  }
  connect();
})();

// Setup panel functionality
function toggleSetup() {
  document.getElementById('setupPanel').classList.toggle('visible');
}

// Populate setup instructions with current server URL
(function() {
  const serverUrl = `http://${window.location.hostname}:${window.location.port || 3456}`;
  const scriptPath = 'C:/Users/YOUR_USER/ai-hq/send-event.ps1';

  document.getElementById('serverAddress').textContent = serverUrl;

  // PowerShell script content
  const scriptContent = `# Send event to AI HQ server
param(
    [string]$Type,
    [string]$Tool = ""
)

$serverUrl = "${serverUrl}"

$sessionId = $env:CLAUDE_SESSION_ID
if (-not $sessionId) {
    $sessionId = (Get-Process -Id $PID).Parent.Id
}

$title = $env:CLAUDE_CWD
if (-not $title) {
    $title = (Get-Location).Path
}
$title = Split-Path $title -Leaf

$body = @{
    type = $Type
    tool = $Tool
    sessionId = "$sessionId"
    title = $title
    timestamp = (Get-Date -Format "o")
} | ConvertTo-Json

try {
    Invoke-RestMethod -Uri "$serverUrl/event" -Method Post -Body $body -ContentType "application/json" -TimeoutSec 1 | Out-Null
} catch {}`;

  document.getElementById('scriptContent').textContent = scriptContent;

  // Hooks configuration
  const hooksConfig = `{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "powershell -ExecutionPolicy Bypass -Command \\"& '${scriptPath}' -Type tool_start -Tool $env:CLAUDE_TOOL_NAME\\""
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "powershell -ExecutionPolicy Bypass -Command \\"& '${scriptPath}' -Type tool_end -Tool $env:CLAUDE_TOOL_NAME\\""
          }
        ]
      }
    ]
  }
}`;

  document.getElementById('hooksConfig').textContent = hooksConfig;
})();
</script>
</body>
</html>
